<!--
===============================================================================
同期影響レポート
===============================================================================
バージョン変更: 1.1.1 → 1.2.0 (Kotlin完全移行完了に伴う原則VIの再定義)

変更された原則:
- VI. Kotlin移行 → VI. Kotlinコード標準: 移行完了を反映し「Kotlin専用」に再定義

追加されたセクション: なし

削除されたセクション:
- 原則VI内の移行関連記述（Javaからの移行、Java相互運用性維持、非推奨Javaパターン禁止）

更新が必要なテンプレート:
- .specify/templates/plan-template.md ✅ 互換性あり（Constitution Checkセクションが存在）
- .specify/templates/spec-template.md ✅ 互換性あり（要件セクションが整合）
- .specify/templates/tasks-template.md ✅ 互換性あり（コミット後の記述と整合）
- .specify/templates/checklist-template.md ✅ 互換性あり（汎用構造）
- .specify/templates/agent-file-template.md ✅ 互換性あり（汎用構造）

関連ドキュメント:
- CLAUDE.md ✅ 更新完了: Project Structure内のJavaディレクトリ参照を削除、Java互換性記述を削除

フォローアップTODO: なし

===============================================================================
-->

# MoLe (Mobile Ledger) 憲章

## コア原則

### I. コードの可読性とメンテナンス性

**絶対ルール**: コードの可読性とメンテナンス性は、すべての開発判断において最優先事項とする。

- すべてのコードは明確な命名規則による自己文書化が必須
- 複雑なロジックには説明コメントを必ず含める
- 関数は単一責任を持ち、簡潔であること
- コードの重複は適切な抽象化により排除する
- すべての公開APIにはKDocドキュメントが必須
- コード構造は確立されたプロジェクトパターンに一貫して従う

**根拠**: 可読性とメンテナンス性の高いコードは技術的負債を削減し、効率的なコラボレーションを
可能にし、プロジェクトの長期的な持続可能性を確保する。

### II. 単体テスト

**絶対ルール**: すべてのコンポーネントには対応する単体テストが必須である。

- すべての新しいクラスや関数はマージ前に単体テストが必須
- テストは正常系と異常系（エッジケース）の両方をカバーする
- 新規コードのテストカバレッジは最低80%を目標とすべき
- テストは独立性、再現性、高速性を持つこと
- テスト名はテスト対象の動作を明確に記述する
- 外部依存関係はモック化してユニットの分離を確保する

**根拠**: 包括的な単体テストはリグレッションを防止し、期待される動作を文書化し、
自信を持ってリファクタリングを行うことを可能にする。

### III. 最小構築・段階的開発

**絶対ルール**: 開発は最小限の構築から始め、各ステップで検証しながら段階的に進める。
こまめなコミットにより進捗を記録し、変更履歴を追跡可能に保つ。

- 最小限の実行可能な実装から開始する
- 次に進む前に各変更が動作することを確認する
- 変更は原子的で、独立してレビュー可能であること
- 各段階では、コードベースを動作する状態に保つ
- 本番ブランチの未完成機能にはフィーチャーフラグを使用すべき
- **こまめなコミット**: 論理的な区切りごとにコミットを行い、大きな変更を蓄積しない
- コミットは小さく、焦点を絞り、自己完結的であること

**根拠**: 段階的開発とこまめなコミットはリスクを軽減し、デバッグを簡素化し、
問題発生時のロールバックを容易にする。継続的インテグレーションの実践を支え、
チームメンバー間の変更追跡を明確にする。

### IV. パフォーマンス最適化

**絶対ルール**: パフォーマンス改善は効果の大きいものから優先的に行う。

- 最適化の前にプロファイリングと計測を行う
- 高影響の最適化（多くのユーザーやクリティカルパスに影響）を最優先で対処する
- 早すぎる最適化は避ける
- パフォーマンス変更にはベンチマーク比較を含める
- 実行速度だけでなくメモリ使用量も考慮する
- データベースクエリは一般的なアクセスパターンに最適化する

**根拠**: 高影響の最適化に集中することで、投資した開発工数あたりのユーザー体験向上を
最大化できる。

### V. アクセシビリティ (Androidアクセシビリティガイドライン)

**絶対ルール**: すべてのユーザーインターフェースコンポーネントはGoogleの
Androidアクセシビリティガイドラインを満たすこと。

- すべてのUI要素にはcontentDescriptionまたはlabelForを設定する
- タッチターゲットは最低48x48dpを確保する（推奨）
- 色のコントラストは最小比率を満たすこと（通常テキスト4.5:1、大きいテキスト3:1）
- TalkBackでの操作を検証し、適切な読み上げ順序を確保する
- フォーカスナビゲーション（D-pad、キーボード）をサポートする
- LiveRegionを使用して動的コンテンツの変更をアナウンスする
- Accessibility Scannerでの検証を実施する
- カスタムViewにはAccessibilityNodeInfoを適切に実装する

**根拠**: Androidアクセシビリティガイドラインに準拠することで、TalkBackユーザーや
運動機能に制限のあるユーザーを含むすべてのAndroidユーザーがアプリを使用できる。

### VI. Kotlinコード標準

**絶対ルール**: すべてのコードはKotlinで記述する。Kotlinのイディオムとモダンな機能を
最大限に活用する。

- Kotlinのモダンな機能を使用する（null安全性、コルーチン、拡張関数）
- データ保持エンティティにはデータクラスを使用する
- 制限された階層の表現にはシールドクラスを使用すべき
- 非同期操作にはKotlinコルーチンを使用する
- Javaコードの新規導入は禁止（プロジェクトは100% Kotlin）

**根拠**: KotlinはJavaと比較してより安全で表現力豊かなコードを提供し、Androidとの
統合が優れており、ボイラープレートを削減する。プロジェクト全体でKotlinに統一することで
一貫性が向上し、メンテナンスが容易になる。

#### Kotlinコードレビュー基準

コードレビューでは以下のKotlin固有の観点を確認する：

**Null安全性**
- `!!`演算子の使用は原則禁止。使用する場合は理由をコメントで明記する
- エルビス演算子（`?:`）やセーフコール（`?.`）を適切に活用する

**不変性**
- `var`より`val`を優先する。可変が必要な場合は理由を明確にする
- `MutableList`/`MutableMap`より不変コレクションを優先する
- データクラスのプロパティは原則`val`で定義する

**スコープ関数**
- `let`、`apply`、`also`、`run`、`with`を用途に応じて適切に使い分ける
- スコープ関数のネストは2段階までとし、可読性を維持する
- 過度なチェーンは避け、必要に応じてローカル変数に分割する

**コルーチン**
- `GlobalScope`の使用は禁止。適切なスコープ（`viewModelScope`等）を使用する
- UIスレッドでの長時間処理は`withContext(Dispatchers.IO)`で回避する
- 例外処理を適切に実装し、エラーがユーザーに通知されることを確認する
- キャンセルに対応し、不要な処理が継続しないことを確認する

### VII. Nix開発環境

**絶対ルール**: 開発環境はNixを使用して再現可能でなければならない。

- すべてのビルド依存関係はflake.nixで指定する
- `nix develop`または`nix develop .#fhs`で完全な開発環境を提供する
- ビルド手順は追加のシステムパッケージなしでNixOSで動作すること
- CI/CDパイプラインは一貫性のために同じNix環境を使用すべき
- Android SDKとツールチェーンのバージョンはNix設定で固定する
- 環境セットアップドキュメントはNix設定と同期して最新に保つ

**根拠**: Nixはすべての開発者マシンとCIシステム間で再現可能なビルドを保証し、
「自分の環境では動く」問題を排除する。

## 開発ワークフロー

### コードレビュープロセス

- すべての変更は少なくとも1人の他の開発者によるレビューが必須
- レビューはすべての憲章原則への準拠を確認する
- 自動チェック（テスト、リント、フォーマット）はレビュー前に通過すること
- レビューコメントはマージ前に対応する
- ドキュメントのみの変更にはセルフレビューが許可される

### テストゲート

- マージ前に単体テストが通過すること
- 統合テスト（該当する場合）が通過すること
- UI変更にはアクセシビリティチェックを実施する
- クリティカルパスの変更にはパフォーマンス回帰テストを実行すべき

### コミット基準

**こまめなコミットの実践**:

- コミットは論理的な区切りごとに行う（ファイル単位、機能単位、修正単位）
- 作業途中でも動作する状態であればコミットする
- 1時間以上コミットしない状況は避ける
- コミットを先延ばしにして大きな変更を蓄積しない

**コミットメッセージ**:

- コミットメッセージはconventional commit形式に従う
- 各コミットは単一の論理的変更を表す
- 作業中のコミットはマージ前にスカッシュする

**根拠**: こまめなコミットにより、問題発生時の原因特定が容易になり、
変更履歴が明確になる。また、作業の進捗が可視化され、
万が一の作業喪失リスクを最小化できる。

## 品質基準

### コード品質

- Kotlinコードはktlintフォーマットチェックを通過すること
- 静的解析の警告はマージ前に対処する
- TODOコメントにはトラッキングissue参照を含める
- 不要なコードはコメントアウトではなく削除する

### ドキュメント

- 公開APIにはKDocドキュメントが必須
- セットアッププロセスの変更時にREADMEを更新する
- アーキテクチャ決定はADR形式で文書化すべき
- ユーザー向け変更には関連するユーザードキュメントを更新する

### パフォーマンス

- アプリ起動時間は参照デバイスで2秒以下を維持する
- UI操作はレスポンシブに感じる100ms以内で完了する
- メモリリークはリリース前に修正する
- バッテリー消費の多い操作は最小化する

## ガバナンス

### 修正プロセス

1. 専用のissueまたはディスカッションで修正を提案する
2. チームレビューとフィードバックのために最低7日間を設ける
3. アクティブなメンテナーからの合意を得る
4. 破壊的変更に対しては移行計画を文書化する
5. 影響を受けるすべてのテンプレートとドキュメントを更新する

### バージョニングポリシー

- **MAJOR**: 原則の削除または根本的な再定義
- **MINOR**: 新しい原則の追加または重要なガイダンスの拡張
- **PATCH**: 明確化、誤字修正、非意味的な改良

### コンプライアンスレビュー

- 憲章への準拠はコードレビューで確認する
- 定期的な監査で原則への準拠を評価すべき
- 違反は文書化され、是正される
- 例外は正当化され、機能計画のComplexity Trackingセクションに文書化する

**バージョン**: 1.2.0 | **批准日**: 2026-01-05 | **最終修正日**: 2026-01-06
