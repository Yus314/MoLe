# 機能仕様書: Hilt 依存性注入セットアップ

**機能ブランチ**: `005-hilt-di-setup`
**作成日**: 2026-01-06
**ステータス**: 完了
**完了日**: 2026-01-06
**マージPR**: #4
**入力**: ユーザー説明: 「テスト駆動開発（TDD）を可能にするためのHiltを使用した依存性注入の実装。テスト時に実際の実装をモックに簡単に置き換えられるよう、アプリケーションコンポーネントを疎結合にする必要がある。コードのテスト容易性を向上させ、モジュラーアーキテクチャをサポートすることが目標。」

## ユーザーシナリオとテスト *(必須)*

### ユーザーストーリー 1 - 開発者がモック依存関係でユニットテストを作成 (優先度: P1)

開発者は、実際のデータベースやネットワーク接続なしでViewModelのユニットテストを書きたいと考えています。ビジネスロジックを分離して検証するために、実際の実装をテストダブル（モック/フェイク）に簡単に置き換える必要があります。

**この優先度の理由**: これがコア価値提案であり、コンポーネントをテスト可能にすることでTDDを実現します。この機能がなければ、機能全体に価値がありません。現在、開発者はViewModelをグローバルシングルトンに直接アクセスしているため、独立してテストできません。

**独立テスト**: 実際のデータベースアクセスの代わりに注入されたモック依存関係を使用するViewModelユニットテストを作成することでテストできます。分離されたユニットテストを可能にすることで即座に価値を提供します。

**受け入れシナリオ**:

1. **前提条件** データアクセスを必要とするViewModelがある場合、**操作** 開発者がユニットテストを書くとき、**期待結果** 本番コードを変更せずにモック実装を提供できる
2. **前提条件** テストクラスのセットアップがある場合、**操作** モック依存関係が設定されたとき、**期待結果** テスト対象のViewModelは実際の実装ではなくそれらのモックを使用する
3. **前提条件** 同じテストクラスに複数のテストがある場合、**操作** 各テストが実行されるとき、**期待結果** 各テストはテストの分離を確保するために新しいモックインスタンスを取得する

---

### ユーザーストーリー 2 - 開発者が適切な依存関係管理で新機能を追加 (優先度: P2)

新しい機能を追加する開発者は、コンポーネントが必要とする依存関係を宣言し、手動の配線なしで実行時にそれらの依存関係が自動的に提供されることを望んでいます。

**この優先度の理由**: テストが有効になった後、次の価値は簡素化された開発ワークフローです。自動的な依存関係解決により定型コードが削減され、配線エラーが防止されます。

**独立テスト**: コンストラクタインジェクションを介して依存関係を宣言する新しいコンポーネントを作成し、手動のインスタンス化なしで実行時に適切なインスタンスを受け取ることを確認することでテストできます。

**受け入れシナリオ**:

1. **前提条件** 依存関係が宣言された新しいViewModelクラスがある場合、**操作** アプリが実行されるとき、**期待結果** すべての依存関係が自動的に提供される
2. **前提条件** データベースアクセスが必要なコンポーネントがある場合、**操作** データアクセス依存関係を宣言するとき、**期待結果** どのように作成されたかを知らなくても適切なインスタンスを受け取る
3. **前提条件** 依存性注入を使用するようにリファクタリングされた既存コンポーネントがある場合、**操作** アプリが起動するとき、**期待結果** すべての機能が以前と同じように動作する

---

### ユーザーストーリー 3 - 開発者がテストデータベースでインストルメンテーションテストを実行 (優先度: P3)

開発者は、本番データの破損を避け、再現可能なテスト条件を確保するために、別のインメモリテストデータベースを使用してAndroidインストルメンテーションテストを実行したいと考えています。

**この優先度の理由**: インストルメンテーションテストはテストストーリーを完成させますが、より多くのインフラストラクチャセットアップが必要です。ユニットテスト（P1）が最も高い即時価値を提供します。

**独立テスト**: データを書き込むインストルメンテーションテストを実行し、テストデータベースを使用していることを確認し、本番データベースが変更されていないことを確認することでテストできます。

**受け入れシナリオ**:

1. **前提条件** インストルメンテーションテストが実行中の場合、**操作** データベースにアクセスするとき、**期待結果** 本番ではなくテストデータベースインスタンスを使用する
2. **前提条件** 複数のインストルメンテーションテストがある場合、**操作** テストが順次実行されるとき、**期待結果** 各テストはクリーンなデータベース状態から開始する
3. **前提条件** インストルメンテーションテストが完了した場合、**操作** アプリが通常通り起動されるとき、**期待結果** 本番データは無傷で影響を受けていない

---

### ユーザーストーリー 4 - チームが一貫した依存関係設定を維持 (優先度: P4)

開発チームは、依存関係がどのように作成および設定されるかについての単一の情報源を求めており、アプリケーションアーキテクチャの理解と依存関係動作の変更を容易にします。

**この優先度の理由**: アーキテクチャ上のメリットは基盤が整った後に現れます。集中化された設定は保守性を向上させますが、初期のテスト機能には必要ありません。

**独立テスト**: すべての依存関係作成ロジックがコードベース全体に散在するのではなく、モジュール定義に集中化されていることを確認することでテストできます。

**受け入れシナリオ**:

1. **前提条件** 依存関係の作成方法を変更する必要がある場合、**操作** 開発者が変更を行うとき、**期待結果** 1か所のみを変更すればよい
2. **前提条件** 新しいチームメンバーがコードベースをレビューする場合、**操作** 依存関係モジュールを見るとき、**期待結果** アプリケーションがどのように配線されているかを理解できる

---

### エッジケース

- 必要な依存関係を提供できない場合（バインディングが見つからない）はどうなるか？
- システムはコンポーネント間の循環依存関係をどのように処理するか？
- スコープ付き依存関係が意図したスコープ外でアクセスされた場合はどうなるか？
- アプリプロセスが強制終了されて復元された場合、依存関係はどのように処理されるか？
- デバッグビルドとリリースビルドで異なる依存関係実装が必要な場合はどうなるか？

## 要件 *(必須)*

### 機能要件

- **FR-001**: アプリケーションは、ViewModelへの依存関係を提供するためにコンストラクタインジェクションを使用しなければならない
- **FR-002**: アプリケーションは、本番コードを変更せずにユニットテストで依存関係をテストダブルに置き換えることを許可しなければならない
- **FR-003**: アプリケーションは、インストルメンテーションテストが代替の依存関係実装（テストデータベースなど）を使用するメカニズムを提供しなければならない
- **FR-004**: 依存関係の作成と設定は、専用のモジュール定義に集中化されなければならない
- **FR-005**: ViewModelは、注入可能な依存関係のために独自の依存関係を直接インスタンス化したり、グローバルシングルトンにアクセスしてはならない
- **FR-006**: データベースインスタンスは注入可能でなければならず、テスト設定がインメモリ代替を提供できるようにする
- **FR-007**: アプリケーションは、単一インスタンスが必要な依存関係（データベース、共有状態）のシングルトンスコープを維持しなければならない
- **FR-008**: 既存のDataシングルトンのオブザーバブル状態は、注入可能な手段を通じてアクセス可能でなければならない
- **FR-009**: すべての既存アプリケーション機能は、移行後も同一に動作し続けなければならない
- **FR-010**: 依存性注入セットアップは、既存のコンポーネントを変更せずに新しい依存関係を追加することをサポートしなければならない

### 主要エンティティ

- **アプリケーションコンポーネント**: アプリのライフサイクル全体で利用可能なアプリケーションスコープの依存関係を提供するルートコンテナ
- **ViewModelコンポーネント**: 設定変更後も存続するViewModel固有の依存関係のコンテナスコープ
- **Activity/Fragmentコンポーネント**: Activity/Fragmentのライフサイクルに紐づいたUI固有の依存関係のコンテナスコープ
- **依存関係モジュール**: 機能またはレイヤーごとにグループ化された関連する依存関係定義の集合
- **テストコンポーネント**: 本番の依存関係をオーバーライドできるテスト中に使用される代替ルートコンテナ

## 成功基準 *(必須)*

### 測定可能な成果

- **SC-001**: 開発者はモック依存関係でViewModelユニットテストを作成でき、データベースやネットワークアクセスなしでビジネスロジックをテストする能力を達成する
- **SC-002**: すべての既存ViewModel（MainModel、NewTransactionModel、ProfileDetailModel、TemplateDetailsViewModel、CurrencySelectorModel）が注入可能でテスト可能である
- **SC-003**: 少なくとも1つのサンプルユニットテストが、注入されたモック依存関係でViewModelをテストすることを実証する
- **SC-004**: 少なくとも1つのサンプルインストルメンテーションテストが、テストデータベース設定でのテストを実証する
- **SC-005**: アプリケーションは移行前と同一に起動および動作する - すべての既存機能がそのまま維持される
- **SC-006**: 新しいViewModelは、手動の配線コードなしで宣言された依存関係で作成できる
- **SC-007**: 依存関係設定が集中化されている - 標準的なインジェクションパターン以外でActivity/Fragmentに散在する依存関係のインスタンス化がない
- **SC-008**: 依存性注入関連のコンパイルエラーなしでビルドが成功する

## 前提条件

- プロジェクトの既存のKotlin 2.0.21とKSP 2.0.21-1.0.26セットアップがHiltのアノテーション処理と互換性がある
- 開発チームは依存性注入の概念に基本的な知識がある
- 既存のグローバルシングルトン（DB、Data）は移行リスクを最小化するために完全に排除するのではなくラップされる
- **移行戦略**: 段階的移行を採用 - MainModelをパイロットとして開始し、パターン確立後に残りのViewModelを後続タスクで移行する
- テストインフラストラクチャ（JUnit、AndroidX Test）はプロジェクトで既に利用可能である

## 明確化事項

### セッション 2026-01-06

- Q: 移行スコープ - 既存ViewModelを一括移行か段階的移行か？ → A: 段階的移行 - 1-2個のパイロットVMから開始し残りを後続で移行
- Q: パイロットViewModel選択 - どのVMから移行を開始するか？ → A: MainModel（最も複雑で多くの依存関係パターンをカバーするため）
