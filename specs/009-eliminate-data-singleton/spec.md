# 機能仕様書: Data.kt シングルトンの廃止

**機能ブランチ**: `009-eliminate-data-singleton`
**作成日**: 2026-01-12
**ステータス**: ドラフト
**入力**: ユーザー説明: 「アプリケーション全体をリファクタリングし、Data.kt シングルトンを廃止して、Hilt による依存性注入を使用した Repository パターンへ完全に移行する。」

## Clarifications

### Session 2026-01-12

- Q: Data.kt の機能を移行する際の優先順位付け戦略は？ → A: 段階的移行（機能カテゴリ別）- プロファイル → タスク管理 → フォーマットの順
- Q: BackgroundTaskManager のスコープとライフサイクルは？ → A: アプリケーションスコープ（@Singleton）- Activity 遷移を超えて状態保持
- Q: 既存の Data/AppStateManager 参照の取り扱いは？ → A: 即座に置換（deprecation なし）- 各フェーズで完全置換
- Q: 同期中にプロファイルが切り替えられた場合の処理は？ → A: 同期継続 - 開始時のプロファイルで完了、UI は現在のプロファイルを表示

## ユーザーシナリオとテスト *(必須)*

### ユーザーストーリー 1 - シングルトンなしでプロファイル選択が動作する (優先度: P1)

ユーザーとして、プロファイルを選択・切り替えることができ、Data.kt シングルトンに依存することなく、選択したプロファイルのデータ（勘定科目、取引）が正しく読み込まれる。

**優先度の理由**: プロファイル管理はコアとなるナビゲーション機構である。プロファイル選択が機能しなければ、ユーザーは台帳データにアクセスできない。これは他のすべての機能が依存する基盤である。

**独立したテスト**: 複数のプロファイルを作成し、それらを切り替え、各プロファイルの勘定科目残高と取引リストが正しく更新されることを確認することで完全にテスト可能。

**受け入れシナリオ**:

1. **前提** 複数のプロファイルが設定された状態でアプリが起動している、**操作** ナビゲーションドロワーから別のプロファイルを選択する、**結果** メイン画面がそのプロファイルの勘定科目と取引を表示するように更新される。
2. **前提** プロファイル A のデータを表示している、**操作** プロファイル B に切り替える、**結果** プロファイル B の勘定科目と取引のみが表示され、プロファイル A のデータは表示されない。
3. **前提** プロファイルが削除された、**操作** プロファイルリストが更新される、**結果** アプリはクラッシュすることなく、別の利用可能なプロファイルに自動的に切り替わる。

---

### ユーザーストーリー 2 - シングルトンなしでデータ同期が動作する (優先度: P1)

ユーザーとして、データ同期（hledger サーバーからの更新）をトリガーでき、Data.kt シングルトンに依存することなく、勘定科目残高と取引リストが正しく更新される。

**優先度の理由**: データ同期は主要な価値提案である - ローカルデータを hledger サーバーと同期させること。これがなければ、アプリは古いデータの読み取り専用となってしまう。

**独立したテスト**: 更新をトリガーし、進捗インジケーターを観察し、サーバーからの新しいデータが正しく表示されることを確認することでテスト可能。

**受け入れシナリオ**:

1. **前提** メイン画面を表示している、**操作** データ更新をトリガーする、**結果** 同期ステータスを示す進捗インジケーターが表示される。
2. **前提** データ同期が進行中である、**操作** 同期が完了する、**結果** 進捗インジケーターが消え、更新された勘定科目残高が表示される。
3. **前提** サーバーに新しい取引が存在する、**操作** データを同期する、**結果** それらの新しい取引が取引リストに表示される。

---

### ユーザーストーリー 3 - 通貨フォーマットが一貫して維持される (優先度: P2)

ユーザーとして、シングルトン移行後も、デバイスのロケール設定に基づいて一貫してフォーマットされた通貨金額がアプリ全体で表示される。

**優先度の理由**: 通貨フォーマットは可読性とユーザー体験に影響するが、フォーマットが不正確でもアプリは使用可能である。重要ではあるがブロッキング要因ではない。

**独立したテスト**: デバイスのロケールを変更し、通貨記号と小数点区切り文字がすべての画面で正しく更新されることを確認することでテスト可能。

**受け入れシナリオ**:

1. **前提** デバイスがドイツ語ロケールに設定されている、**操作** 勘定科目残高を表示する、**結果** 小数点区切り文字としてカンマを使用した金額が表示される（例: 「1.234,56 EUR」）。
2. **前提** 新しい取引を作成している、**操作** 金額を入力する、**結果** アプリはロケールの小数点区切り文字を使用した入力を受け付ける。
3. **前提** アプリ実行中にデバイスのロケールが変更された、**操作** 新しい画面に移動する、**結果** 通貨フォーマットが新しいロケールを反映する。

---

### ユーザーストーリー 4 - テーマ変更が正しく適用される (優先度: P2)

ユーザーとして、異なるテーマカラーを持つ別のプロファイルを選択すると、Data.kt シングルトンを必要とせずにアプリの外観が即座に更新される。

**優先度の理由**: ビジュアルテーマはユーザー体験を向上させるが、コア機能には影響しない。テーマが不正確でもユーザーはアプリを使用できる。

**独立したテスト**: 異なるテーマカラーを持つプロファイルを作成し、それらを切り替えることでテスト可能。

**受け入れシナリオ**:

1. **前提** 異なるテーマカラーを持つ2つのプロファイルがある、**操作** それらを切り替える、**結果** アプリの配色が選択したプロファイルに合わせて更新される。
2. **前提** プロファイルのテーマカラーを編集している、**操作** 変更を保存する、**結果** アプリの外観が即座に更新される。

---

### ユーザーストーリー 5 - ナビゲーションドロワーの状態が維持される (優先度: P3)

ユーザーとして、Data.kt シングルトンなしでナビゲーションドロワーが正しく開閉し、適切に状態が維持される。

**優先度の理由**: ドロワーの状態は軽微な UX の懸念事項である - 壊れていても、ユーザーは他の手段でナビゲートできる。

**独立したテスト**: ドロワーを開閉し、正しく応答することを確認することでテスト可能。

**受け入れシナリオ**:

1. **前提** ドロワーが閉じている、**操作** 左端からスワイプする、**結果** ドロワーが開く。
2. **前提** ドロワーが開いている、**操作** プロファイルを選択する、**結果** ドロワーが自動的に閉じる。

---

### ユーザーストーリー 6 - すべての ViewModel が独立してテスト可能になる (優先度: P3)

開発者として、グローバルなシングルトン状態をセットアップすることなく、モックリポジトリを注入して任意の ViewModel をユニットテストできる。

**優先度の理由**: これは開発者向けの利点であり、より良いテストカバレッジと迅速な開発イテレーションを可能にする。ユーザーには直接見えない。

**独立したテスト**: モックリポジトリを使用して ViewModel のユニットテストを書き、グローバル状態のセットアップなしでパスすることを確認することでテスト可能。

**受け入れシナリオ**:

1. **前提** 以前 Data.kt にアクセスしていた ViewModel がある、**操作** ユニットテストを書く、**結果** シングルトンにアクセスせずにモックリポジトリを注入できる。
2. **前提** テスト対象の ViewModel がある、**操作** 様々なシナリオをテストする、**結果** 各テストが共有可変状態なしで独立して実行される。

---

### エッジケース

- プロファイルが設定されていない状態でアプリが起動した場合はどうなるか？
  - アプリはこれを適切に処理し、プロファイル作成を促すプロンプトを表示する。
- 操作中にデータ同期が失敗した場合、システムはどのように処理するか？
  - エラー状態は適切な UI フィードバックを通じてユーザーに伝達され、アプリは安定した状態を維持する。
- バックグラウンド同期の実行中にプロファイルが切り替えられた場合はどうなるか？
  - 同期は開始時のプロファイルで継続・完了する（キャンセルしない）。UI は現在選択中のプロファイルのデータを表示し、同期完了後も切り替え先プロファイルの表示を維持する。同期結果は開始時のプロファイルのデータとして保存される。
- バックグラウンド操作中にロケールが変更された場合、アプリはどのように動作するか？
  - 既にフォーマットされた数値はそのまま維持され、新しいフォーマットは更新されたロケールを使用する。

## 要件 *(必須)*

### 機能要件

- **FR-001**: システムは Hilt で注入された ProfileRepository を通じてのみプロファイルデータアクセスを提供しなければならない。
- **FR-002**: システムはシングルトンオブジェクトではなく、Hilt で注入可能なサービスを通じてバックグラウンドタスク状態（実行中、進捗）を公開しなければならない。
- **FR-003**: システムは現在のロケールを尊重する注入可能なユーティリティクラスを通じて通貨フォーマット機能を提供しなければならない。
- **FR-004**: システムは依存性注入を通じてアクセス可能なスコープ付き状態ホルダーを通じてドロワーの開閉状態を公開しなければならない。
- **FR-005**: システムは注入された状態フローを通じて更新ステータス情報（最終更新日、カウント）の監視を許可しなければならない。
- **FR-006**: ViewModel はすべての依存関係をコンストラクタ注入で受け取らなければならない。
- **FR-007**: 移行後、システムは UI コードから Data オブジェクトまたは AppStateManager への静的参照を持ってはならない。
- **FR-008**: Data.kt ファイルが削除された後も、すべての既存機能が動作し続けなければならない。
- **FR-009**: システムはライフサイクル対応フローを使用して Activity でプロファイル変更の監視をサポートしなければならない。
- **FR-010**: システムはライフサイクル対応フローを使用して Activity でバックグラウンドタスク進捗の監視をサポートしなければならない。

### FR 依存関係

以下の依存関係により、実装順序が制約される:

| FR | 依存先 | 理由 |
|----|--------|------|
| FR-004 (ドロワー状態) | FR-002 | AppStateService は BackgroundTaskManager と同時に作成され、ドロワー状態も管理する |
| FR-005 (更新ステータス) | FR-002 | AppStateService で lastSyncInfo を管理する |
| FR-009 (プロファイル監視) | FR-001 | ProfileRepository.currentProfile を使用 |
| FR-010 (タスク進捗監視) | FR-002 | BackgroundTaskManager.taskProgress を使用 |

**実装順序**: FR-001 → FR-002 → FR-003/FR-004/FR-005（並列可） → FR-006〜FR-010（検証）

### 主要エンティティ

- **AppStateService**: UI レベルのアプリケーション状態（バックグラウンドタスクステータス、ドロワー状態、ロケール設定、通貨フォーマット設定）を管理する注入可能なサービス。
- **ProfileRepository**: プロファイルデータアクセスを管理するリポジトリ（既に部分的に存在し、完成が必要）。
- **BackgroundTaskManager**: バックグラウンドタスクの状態と進捗を調整する注入可能なマネージャー。アプリケーションスコープ（@Singleton）で管理され、Activity 遷移を超えて状態を保持する。ただし、プロセス再起動時（システムによる強制終了後の再起動を含む）は状態がリセットされ、実行中タスクは失われる。
- **CurrencyFormatter**: ロケール対応の通貨および数値フォーマット用の注入可能なユーティリティ。

## 成功基準 *(必須)*

### 測定可能な成果

- **SC-001**: コードベースに `Data.` または `AppStateManager.` への静的参照がゼロ件存在する（grep 検索で結果がゼロ件であることで検証）。
- **SC-002**: すべての既存ユニットテストがテストセットアップの変更なしでパスする（依存性注入の変更を除く）。
- **SC-003**: すべてのユーザー向け機能（プロファイル切り替え、データ同期、取引作成、テーマ）がリファクタリング前と同一に機能する。
- **SC-004**: 新しい ViewModel はコンストラクタ注入されたモック依存関係のみを使用してテストできる。
- **SC-005**: Data.kt ファイルがプロジェクトから完全に削除された状態でアプリケーションが正常にビルドされる。
- **SC-006**: アプリケーションの起動時間がリファクタリング前のパフォーマンスの 10% 以内に維持される。

### SC-006 計測方法

- **計測区間**: Cold start（`adb shell am start-activity`）から MainActivityCompose の UI 表示完了まで
- **計測方法**: `adb shell am start -W` コマンドの `TotalTime` 出力値を使用
- **計測条件**: アプリ強制終了後、3回計測の中央値を採用
- **参照デバイス**: Pixel 9（RAM 12GB、Android 15）
- **ベースライン**: リファクタリング開始前に同条件で計測し、記録しておく

## 前提条件

- 既存の ProfileRepository 実装は堅固な基盤を提供しており、軽微な拡張のみが必要である。
- アプリ状態にアクセスする必要があるすべての ViewModel は @HiltViewModel パターンに移行される。
- Data.observeProfile() を使用している Activity は、代わりに ViewModel から収集するようにリファクタリングされる。
- 型エイリアス `typealias Data = AppStateManager` は AppStateManager の非推奨化とともに削除される。
- バックグラウンドタスク調整（backgroundTaskStarted/backgroundTaskFinished）は専用の注入可能なサービスに移動される。

## 移行戦略

移行は **段階的移行（機能カテゴリ別）** アプローチで実施する:

1. **フェーズ 1: プロファイル管理** - ProfileRepository の完成と Data.profiles/currentProfile の置換
2. **フェーズ 2: バックグラウンドタスク管理** - BackgroundTaskManager の導入と Data.backgroundTaskStarted/Finished の置換
3. **フェーズ 3: ロケール/通貨フォーマット** - CurrencyFormatter の導入と Data.locale 関連機能の置換

各フェーズ完了後にテストを実行し、回帰がないことを確認してから次のフェーズに進む。

**置換ポリシー**: 各フェーズで対象となる Data/AppStateManager への参照は即座に完全置換する（@Deprecated アノテーションによる段階的移行は行わない）。これにより新旧の方法が混在するリスクを排除し、コードベースの一貫性を維持する。

## スコープ外

- Room データベーススキーマまたはマイグレーションの変更。
- 現在存在する以上の新機能または機能の追加。
- LiveData からの完全な移行（シングルトンパターンのみが対処される）。
- 現在のパフォーマンスレベルを維持する以上のパフォーマンス最適化。
- UI/UX の再設計。
